import{Socket as e}from"phoenix";function t(){return t=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(e[i]=n[i])}return e},t.apply(this,arguments)}var n,i,s;!function(e){e.MAINNET="mainnet",e.TESTNET="testnet"}(n||(n={})),function(e){e.ITEM_METADATA_UPDATED="item_metadata_updated",e.ITEM_LISTED="item_listed",e.ITEM_SOLD="item_sold",e.ITEM_TRANSFERRED="item_transferred",e.ITEM_RECEIVED_OFFER="item_received_offer",e.ITEM_RECEIVED_BID="item_received_bid",e.ITEM_CANCELLED="item_cancelled"}(i||(i={})),function(e){e[e.DEBUG=20]="DEBUG",e[e.INFO=30]="INFO",e[e.WARN=40]="WARN",e[e.ERROR=50]="ERROR"}(s||(s={}));const o={[n.MAINNET]:"wss://stream.openseabeta.com/socket",[n.TESTNET]:"wss://testnets-stream.openseabeta.com/socket"};class c{constructor({network:c=n.MAINNET,token:r,apiUrl:h,connectOptions:a,logLevel:l=s.INFO,onError:E=(e=>this.error(e))}){this.socket=void 0,this.channels=void 0,this.logLevel=void 0,this.connect=()=>{this.debug("Connecting to socket"),this.socket.connect()},this.disconnect=(e=(()=>this.info("Succesfully disconnected from socket")))=>(this.channels.clear(),this.socket.disconnect(e)),this.createChannel=e=>{const t=this.socket.channel(e);return t.join().receive("ok",()=>this.info(`Successfully joined channel "${e}"`)).receive("error",()=>this.error(`Failed to join channel "${e}"`)),this.channels.set(e,t),t},this.getChannel=e=>{let t=this.channels.get(e);return t||(this.debug(`Creating channel for topic: "${e}"`),t=this.createChannel(e)),t},this.on=(e,t,n)=>{this.socket.connect();const i=`collection:${t}`;this.debug(`Fetching channel ${i}`);const s=this.getChannel(i);return this.debug(`Subscribing to ${e} events on ${i}`),s.on(e,n),()=>{this.debug(`Unsubscribing from ${e} events on ${i}`),s.leave().receive("ok",()=>{this.channels.delete(i),this.info(`Succesfully left channel "${i}" listening for ${e}`)})}},this.onItemMetadataUpdated=(e,t)=>(this.debug(`Listening for item metadata updates on "${e}"`),this.on(i.ITEM_METADATA_UPDATED,e,t)),this.onItemCancelled=(e,t)=>(this.debug(`Listening for item cancellations on "${e}"`),this.on(i.ITEM_CANCELLED,e,t)),this.onItemListed=(e,t)=>(this.debug(`Listening for item listings on "${e}"`),this.on(i.ITEM_LISTED,e,t)),this.onItemSold=(e,t)=>(this.debug(`Listening for item sales on "${e}"`),this.on(i.ITEM_SOLD,e,t)),this.onItemTransferred=(e,t)=>(this.debug(`Listening for item transfers on "${e}"`),this.on(i.ITEM_TRANSFERRED,e,t)),this.onItemReceivedOffer=(e,t)=>(this.debug(`Listening for item offers on "${e}"`),this.on(i.ITEM_RECEIVED_OFFER,e,t)),this.onItemReceivedBid=(e,t)=>(this.debug(`Listening for item bids on "${e}"`),this.on(i.ITEM_RECEIVED_BID,e,t)),this.onEvents=(e,t,n)=>{const i=t.map(t=>this.on(t,e,n));return()=>{for(const e of i)e()}};const d="undefined"!=typeof window?window.WebSocket:void 0;this.socket=new e(h||o[c],t({params:{token:r},transport:d},a)),this.socket.onError(E),this.channels=new Map,this.logLevel=l}debug(e){this.logLevel<=s.DEBUG&&console.debug(`[DEBUG]: ${e}`)}info(e){this.logLevel<=s.INFO&&console.info(`[INFO]: ${e}`)}warn(e){this.logLevel<=s.WARN&&console.warn(`[WARN]: ${e}`)}error(e){this.logLevel<=s.ERROR&&console.error(`[ERROR]: ${e}`)}}export{i as EventType,s as LogLevel,n as Network,c as OpenSeaStreamClient};
//# sourceMappingURL=index.modern.js.map
